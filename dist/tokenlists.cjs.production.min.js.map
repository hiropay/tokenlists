{"version":3,"file":"tokenlists.cjs.production.min.js","sources":["../src/types.ts","../src/getVersionUpgrade.ts","../src/versionComparator.ts","../src/diffTokenLists.ts","../src/index.ts","../src/isVersionUpdate.ts","../src/minVersionBump.ts","../src/nextVersion.ts"],"sourcesContent":["type ExtensionValue = string | number | boolean | null | undefined;\n\nexport enum TokenlistTabNames {\n  PEG_USD = \"USD pegged\",\n  PEG_EUR = \"EUR pegged\",\n\n  STABLECOIN = \"Stablecoin\",\n}\n\nexport interface TokenInfo {\n  readonly chainId: number;\n  readonly address: string;\n  readonly name: string;\n  readonly decimals: number;\n  readonly symbol: string;\n  readonly logoURI?: string;\n  readonly tags?: TokenlistTabNames[];\n  readonly extensions?: {\n    readonly [key: string]:\n      | {\n          [key: string]:\n            | {\n                [key: string]: ExtensionValue;\n              }\n            | ExtensionValue;\n        }\n      | ExtensionValue;\n  };\n}\n\nexport interface Version {\n  readonly major: number;\n  readonly minor: number;\n  readonly patch: number;\n}\n\nexport interface TokenList {\n  readonly name: string;\n  readonly timestamp: string;\n  readonly version: Version;\n  readonly tokens: TokenInfo[];\n  readonly keywords?: string[];\n  readonly tags?: any;\n  readonly logoURI?: string;\n}\n","import { Version } from \"./types\";\n\n/**\n * Enum describing types of version differences\n */\nexport enum VersionUpgrade {\n  NONE,\n  PATCH,\n  MINOR,\n  MAJOR,\n}\n\n/**\n * Return the upgrade type from the base version to the update version.\n * Note that downgrades and equivalent versions are both treated as `NONE`.\n * @param base base list\n * @param update update to the list\n */\nexport function getVersionUpgrade(\n  base: Version,\n  update: Version\n): VersionUpgrade {\n  if (update.major > base.major) {\n    return VersionUpgrade.MAJOR;\n  }\n  if (update.major < base.major) {\n    return VersionUpgrade.NONE;\n  }\n  if (update.minor > base.minor) {\n    return VersionUpgrade.MINOR;\n  }\n  if (update.minor < base.minor) {\n    return VersionUpgrade.NONE;\n  }\n  return update.patch > base.patch ? VersionUpgrade.PATCH : VersionUpgrade.NONE;\n}\n","import { Version } from \"./types\";\n\n/**\n * Comparator function that allows sorting version from lowest to highest\n * @param versionA version A to compare\n * @param versionB version B to compare\n * @returns -1 if versionA comes before versionB, 0 if versionA is equal to version B, and 1 if version A comes after version B\n */\nexport function versionComparator(\n  versionA: Version,\n  versionB: Version\n): -1 | 0 | 1 {\n  if (versionA.major < versionB.major) {\n    return -1;\n  } else if (versionA.major > versionB.major) {\n    return 1;\n  } else if (versionA.minor < versionB.minor) {\n    return -1;\n  } else if (versionA.minor > versionB.minor) {\n    return 1;\n  } else if (versionA.patch < versionB.patch) {\n    return -1;\n  } else if (versionA.patch > versionB.patch) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","import { TokenInfo } from \"./types\";\n\nexport type TokenInfoChangeKey = Exclude<\n  keyof TokenInfo,\n  \"address\" | \"chainId\"\n>;\nexport type TokenInfoChanges = Array<TokenInfoChangeKey>;\n\n/**\n * compares two token info key values\n * this subset of full deep equal functionality does not work on objects or object arrays\n * @param a comparison item a\n * @param b comparison item b\n */\nfunction compareTokenInfoProperty(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  if (typeof a !== typeof b) return false;\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.every((el, i) => b[i] === el);\n  }\n  return false;\n}\n\n/**\n * Differences between a base list and an updated list.\n */\nexport interface TokenListDiff {\n  /**\n   * Tokens from updated with chainId/address not present in base list\n   */\n  readonly added: TokenInfo[];\n  /**\n   * Tokens from base with chainId/address not present in the updated list\n   */\n  readonly removed: TokenInfo[];\n  /**\n   * The token info that changed\n   */\n  readonly changed: {\n    [chainId: number]: {\n      [address: string]: TokenInfoChanges;\n    };\n  };\n}\n\n/**\n * Computes the diff of a token list where the first argument is the base and the second argument is the updated list.\n * @param base base list\n * @param update updated list\n */\nexport function diffTokenLists(\n  base: TokenInfo[],\n  update: TokenInfo[]\n): TokenListDiff {\n  const indexedBase = base.reduce<{\n    [chainId: number]: { [address: string]: TokenInfo };\n  }>((memo, tokenInfo) => {\n    if (!memo[tokenInfo.chainId]) memo[tokenInfo.chainId] = {};\n    memo[tokenInfo.chainId][tokenInfo.address] = tokenInfo;\n    return memo;\n  }, {});\n\n  const newListUpdates = update.reduce<{\n    added: TokenInfo[];\n    changed: {\n      [chainId: number]: {\n        [address: string]: TokenInfoChanges;\n      };\n    };\n    index: {\n      [chainId: number]: {\n        [address: string]: true;\n      };\n    };\n  }>(\n    (memo, tokenInfo) => {\n      const baseToken = indexedBase[tokenInfo.chainId]?.[tokenInfo.address];\n      if (!baseToken) {\n        memo.added.push(tokenInfo);\n      } else {\n        const changes: TokenInfoChanges = Object.keys(tokenInfo)\n          .filter(\n            (s): s is TokenInfoChangeKey => s !== \"address\" && s !== \"chainId\"\n          )\n          .filter((s) => {\n            return !compareTokenInfoProperty(tokenInfo[s], baseToken[s]);\n          });\n        if (changes.length > 0) {\n          if (!memo.changed[tokenInfo.chainId]) {\n            memo.changed[tokenInfo.chainId] = {};\n          }\n          memo.changed[tokenInfo.chainId][tokenInfo.address] = changes;\n        }\n      }\n\n      if (!memo.index[tokenInfo.chainId]) {\n        memo.index[tokenInfo.chainId] = {\n          [tokenInfo.address]: true,\n        };\n      } else {\n        memo.index[tokenInfo.chainId][tokenInfo.address] = true;\n      }\n\n      return memo;\n    },\n    { added: [], changed: {}, index: {} }\n  );\n\n  const removed = base.reduce<TokenInfo[]>((list, curr) => {\n    if (\n      !newListUpdates.index[curr.chainId] ||\n      !newListUpdates.index[curr.chainId][curr.address]\n    ) {\n      list.push(curr);\n    }\n    return list;\n  }, []);\n\n  return {\n    added: newListUpdates.added,\n    changed: newListUpdates.changed,\n    removed,\n  };\n}\n","import tokenlist from \"./tokenlist-v1.json\";\nimport chainlist from \"./chainlist-v1.json\";\nimport routerlist from \"./routerlist-v1.json\";\nimport tokenschema from \"./tokenlist-v1.json\";\n\nexport * from \"./types\";\nexport * from \"./isVersionUpdate\";\nexport * from \"./getVersionUpgrade\";\nexport * from \"./diffTokenLists\";\nexport * from \"./minVersionBump\";\nexport * from \"./nextVersion\";\nexport * from \"./versionComparator\";\n\nexport { tokenschema, tokenlist, chainlist, routerlist };\n\nexport function getChain(chainId: number) {\n  return chainlist.chains.find((needle: any) => {\n    return needle.chainId === chainId;\n  });\n}\n\nexport function getTokens(chainId: number) {\n  return tokenlist.tokens.filter((needle: any) => {\n    return needle.chainId === chainId;\n  });\n}\n\nexport function getRouters(chainId: number) {\n  return routerlist.routers.filter((needle: any) => {\n    return needle.chainId === chainId;\n  });\n}\n","import { versionComparator } from './versionComparator';\nimport { Version } from './types';\n\n/**\n * Returns true if versionB is an update over versionA\n */\nexport function isVersionUpdate(base: Version, update: Version): boolean {\n  return versionComparator(base, update) < 0;\n}","import { diffTokenLists } from \"./diffTokenLists\";\nimport { VersionUpgrade } from \"./getVersionUpgrade\";\nimport { TokenInfo } from \"./types\";\n\n/**\n * Returns the minimum version bump for the given list\n * @param baseList the base list of tokens\n * @param updatedList the updated list of tokens\n */\nexport function minVersionBump(\n  baseList: TokenInfo[],\n  updatedList: TokenInfo[]\n): VersionUpgrade {\n  const diff = diffTokenLists(baseList, updatedList);\n  if (diff.removed.length > 0) return VersionUpgrade.MAJOR;\n  if (diff.added.length > 0) return VersionUpgrade.MINOR;\n  if (Object.keys(diff.changed).length > 0) return VersionUpgrade.PATCH;\n  return VersionUpgrade.NONE;\n}\n","import { VersionUpgrade } from \"./getVersionUpgrade\";\nimport { Version } from \"./types\";\n\n/**\n * Returns the next version of the list given a base version and the upgrade type\n * @param base current version\n * @param bump the upgrade type\n */\nexport function nextVersion(base: Version, bump: VersionUpgrade): Version {\n  switch (bump) {\n    case VersionUpgrade.NONE:\n      return base;\n\n    case VersionUpgrade.MAJOR:\n      return { major: base.major + 1, minor: 0, patch: 0 };\n\n    case VersionUpgrade.MINOR:\n      return {\n        major: base.major,\n        minor: base.minor + 1,\n        patch: 0,\n      };\n\n    case VersionUpgrade.PATCH:\n      return {\n        major: base.major,\n        minor: base.minor,\n        patch: base.patch + 1,\n      };\n  }\n}\n"],"names":["TokenlistTabNames","VersionUpgrade","versionComparator","versionA","versionB","major","minor","patch","diffTokenLists","base","update","indexedBase","reduce","memo","tokenInfo","chainId","address","newListUpdates","baseToken","_indexedBase$tokenInf","changes","Object","keys","filter","s","a","b","Array","isArray","every","el","i","length","changed","added","push","index","removed","list","curr","chainlist","chains","find","needle","routerlist","routers","tokenlist","tokens","MAJOR","NONE","MINOR","PATCH","baseList","updatedList","diff","bump"],"mappings":"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"}